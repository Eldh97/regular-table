<!--
   
   Copyright (c) 2020, the Regular Table Authors.
   
   This file is part of the Regular Table library, distributed under the terms of
   the Apache License 2.0.  The full license can be found in the LICENSE file.

-->

<!--

    An example of a multi-dimensional pivot table using [`regular-table`](https://github.com/jpmorganchase/regular-table)
    and [`perspective`](https://perspective.finos.org/). 
    
-->

<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <script src="../node_modules/@finos/perspective/dist/umd/perspective.js"></script>
    <script src="../dist/umd/regular-table.js"></script>
    <link rel='stylesheet' href="../dist/css/material.css">
    <style>
        regular-table table {
            user-select: none;
        }
        /* Type Styles */
        .psp-align-right {
            text-align: right;
        }
        .psp-align-left {
            text-align: left;
        }
        .psp-positive {
            color: #1078d1;
        }
        .psp-negative {
            color: #de3838;
        }
        /* Tree Styles */
        .psp-tree-header {
           background-image: linear-gradient(to right, transparent 9px, #eee 10px, transparent 11px);
        }
        .psp-tree-label:before {
            color: #ccc;
            font-family: "Material Icons";
            padding-right: 11px;
        }
        .psp-tree-label-expand:before {
            content: "add"
        }
        .psp-tree-label-collapse:before {
            content: "remove"
        }
        .psp-tree-label:hover:before {
            color: #1078d1;
            text-shadow: 0px 0px 5px #1078d1;
        }
        .psp-tree-edge {
            border-right: 1px solid #ddd;
        }
        .psp-tree-edge:not(.psp-tree-leaf):not(.psp-tree-label) {
            pointer-events: none;
        }
        .psp-tree-indent {
            min-width: 20px;
            max-width: 20px;
        }
        .psp-tree-leaf {
            padding-left: 24px;
        }
        /* Header Styles */
        .psp-header-border {
            border-right: 1px solid #ddd;
        }
        .psp-header-sort-desc:after {
            font-family: "Material Icons";
            font-size: 10px;
            content: "arrow_downward"
        }
        .psp-header-sort-asc:after {
            font-family: "Material Icons";
            font-size: 10px;
            content: "arrow_upward"
        }
        .psp-header-sort-col-desc:after {
            font-family: "Material Icons";
            font-size: 10px;
            content: "arrow_back"
        }
        .psp-header-sort-col-asc:after {
            font-family: "Material Icons";
            font-size: 10px;
            content: "arrow_forward"
        }
    </style>
</head>

<body>

    <regular-table></regular-table>

    <script>
        const FORMATTERS = {
            datetime: Intl.DateTimeFormat("en-us"),
            date: Intl.DateTimeFormat("en-us"),
            integer: Intl.NumberFormat("en-us"),
            float: new Intl.NumberFormat("en-us", {
                style: "decimal",
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
            }),
        };

        function _format(parts, val) {
            if (val === null) {
                return "-";
            }
            const type = this._schema[parts[parts.length - 1]] || "string";
            return FORMATTERS[type]?.format(val) || val;
        }

        function columnHeaderStyleListener(regularTable) {
            const header_depth = regularTable._view_cache.config.row_pivots.length - 1;
            for (const td of regularTable.querySelectorAll("thead tr:last-child th")) {
                const metadata = regularTable.getMeta(td);
                const sort = this._config.sort.find((x) => x[0] === metadata.column_header[metadata.column_header.length - 1]);
                let needs_border = metadata.row_header_x === header_depth;
                needs_border = needs_border || (metadata.x + 1) % this._config.columns.length === 0;
                td.classList.toggle("psp-header-border", needs_border);
                td.classList.toggle("psp-header-group", false);
                td.classList.toggle("psp-header-leaf", true);
                td.classList.toggle("psp-header-sort-asc", !!sort && sort[1] === "asc");
                td.classList.toggle("psp-header-sort-desc", !!sort && sort[1] === "desc");
                td.classList.toggle("psp-header-sort-col-asc", !!sort && sort[1] === "col asc");
                td.classList.toggle("psp-header-sort-col-desc", !!sort && sort[1] === "col desc");
            }
        }

        function groupHeaderStyleListener(regularTable) {
            const header_depth = regularTable._view_cache.config.row_pivots.length - 1;
            for (const td of regularTable.querySelectorAll("thead tr:not(:last-child) th")) {
                const metadata = regularTable.getMeta(td);
                let needs_border = metadata.row_header_x === header_depth || metadata.x >= 0;
                td.classList.toggle("psp-header-group", true);
                td.classList.toggle("psp-header-leaf", false);
                td.classList.toggle("psp-header-border", needs_border);
            }
        }

        function treeStyleListener(regularTable) {
            for (const td of regularTable.querySelectorAll("tbody th")) {
                const header_depth = regularTable._view_cache.config.row_pivots.length - 1;
                const metadata = regularTable.getMeta(td);
                const is_empty = !!metadata.value && metadata.value.trim().length > 0;
                const is_leaf = metadata.row_header_x >= this._config.row_pivots.length;
                const next = !!regularTable.getMeta({row_header_x: metadata.row_header_x + 1, y: metadata.y + 1});
                td.classList.toggle("psp-tree-header", metadata.value === "");
                td.classList.toggle("psp-tree-label", is_empty && !is_leaf);
                td.classList.toggle("psp-tree-label-expand", is_empty && !is_leaf && !next);
                td.classList.toggle("psp-tree-label-collapse", is_empty && !is_leaf && next);
                td.classList.toggle("psp-tree-leaf", is_empty && is_leaf);
                td.classList.toggle("psp-tree-edge", metadata.row_header_x === header_depth);
                td.classList.toggle("psp-tree-indent", metadata.row_header_x < header_depth);
            }
        }

        function typeStyleListener(regularTable) {
            for (const td of regularTable.querySelectorAll("td, thead tr:last-child th")) {
                const metadata = regularTable.getMeta(td);
                if (metadata.x >= 0) {
                    const column_path = this._column_paths[metadata.x];
                    const column_path_parts = column_path.split("|");
                    const type = this._schema[column_path_parts[column_path_parts.length - 1]];
                    const is_numeric = type === "integer" || type === "float";
                    const float_val = is_numeric && parseFloat(metadata.value);
                    td.classList.toggle("psp-align-right", is_numeric);
                    td.classList.toggle("psp-align-left", !is_numeric);
                    td.classList.toggle("psp-positive", float_val > 0);
                    td.classList.toggle("psp-negative", float_val < 0);
                }
            }
        }

        /// sort

        function increment_sort(column_name) {
            const sort = [];
            let found = false;
            for (const sort_term of this._config.sort) {
                const [_column_name, _sort_dir] = sort_term;
                if (_column_name === column_name) {
                    found = true;
                    const term = create_sort.call(this, column_name, _sort_dir);
                    if (sort) {
                        sort.push(term);
                    }
                } else {
                    sort.push(sort_term);
                }
            }
            if (!found) {
                sort.push([column_name, "desc"]);
            }
            return sort;
        }

        const sort_increment_order_no_pivot = {desc: "asc", asc: undefined};
        const sort_increment_order_column_pivot = {desc: "asc", asc: "col desc", "col desc": "col asc", "col asc": undefined};
        
        function create_sort(column_name, sort_dir) {
            let order;
            if (this._config.column_pivots.length > 0) {
                order = sort_increment_order_column_pivot;
            } else {
                order = sort_increment_order_no_pivot;
            }
            const inc_sort_dir = sort_dir ? order[sort_dir] : "desc";
            if (inc_sort_dir) {
                return [column_name, inc_sort_dir];
            }
        }

        function override_sort(column_name) {
            for (const [_column_name, _sort_dir] of this._config.sort) {
                if (_column_name === column_name) {
                    const sort = create_sort.call(this, column_name, _sort_dir);
                    return sort ? [sort] : [];
                }
            }
            return [[column_name, "desc"]];
        }

        async function sortHandler(regularTable, event) {
            const meta = regularTable.getMeta(event.target);
            const column_name = meta.column_header[meta.column_header.length - 1];
            let sort;
            if (event.shiftKey) {
                sort = increment_sort.call(this, column_name);
            } else {
                sort = override_sort.call(this, column_name);
            }

            this._view = this._table.view({...this._config, sort: sort});
            await create_view_cache(this._table, this._view, this);
            await regularTable.draw();
        }

        async function expandCollapseHandler(regularTable, event) {
            const meta = regularTable.getMeta(event.target);
            const is_collapse = event.target.classList.contains("psp-tree-label-collapse");
            if (event.shiftKey && is_collapse) {
                this._view.set_depth(meta.row_header.filter((x) => x !== undefined).length - 2);
            } else if (event.shiftKey) {
                this._view.set_depth(meta.row_header.filter((x) => x !== undefined).length - 1);
            } else if (is_collapse) {
                this._view.collapse(meta.y);
            } else {
                this._view.expand(meta.y);
            }
            for (const size_key of Object.keys(regularTable.table_model._column_sizes.auto)) {
                if (size_key <= this._config.row_pivots.length) {
                    regularTable.table_model._column_sizes.auto[size_key] = undefined;
                }
            }
            this._num_rows = await this._view.num_rows();
            this._num_columns = await this._view.num_columns();
            regularTable.draw();
        }

        async function mousedownListener(regularTable, event) {
            if (event.target.classList.contains("psp-tree-label") && event.offsetX < 26) {
                expandCollapseHandler.call(this, regularTable, event);
            } else if (event.target.classList.contains("psp-header-leaf")) {
                sortHandler.call(this, regularTable, event);
            }
        }

        function* _tree_header(paths = []) {
            for (let path of paths) {
                path = ["TOTAL", ...path];
                yield path
                    .slice(0, path.length - 1)
                    .fill("")
                    .concat(path[path.length - 1]);
            }
        }

        async function dataListener(x0, y0, x1, y1) {
            let columns = {};
            if (x1 - x0 > 0 && y1 - y0 > 0) {
                columns = await this._view.to_columns({
                    start_row: y0,
                    start_col: x0,
                    end_row: y1,
                    end_col: x1,
                    id: this._config.row_pivots.length > 0,
                });
            }

            const data = [];
            const column_headers = [];
            for (const path of this._column_paths.slice(x0, x1)) {
                const path_parts = path.split("|");
                data.push(columns[path].map((x) => _format.call(this, path_parts, x)));
                column_headers.push(path_parts);
            }

            return {
                num_rows: this._num_rows,
                num_columns: this._column_paths.length,
                row_headers: Array.from(_tree_header(columns.__ROW_PATH__)),
                column_headers,
                data,
            };
        }

        async function create_view_cache(table, view, extend = {}) {
            return Object.assign(extend, {
                _view: view,
                _table: table,
                _table_schema: await table.schema(),
                _config: await view.get_config(),
                _num_rows: await view.num_rows(),
                _schema: await view.schema(),
                _column_paths: (await view.column_paths()).filter((path) => {
                    return path !== "__ROW_PATH__" && path !== "__ID__";
                }),
            });
        }

        /**********************************************************************
         *
         * Example
         *
         */

        const URL = "../node_modules/superstore-arrow/superstore.arrow";
        const perspective = window.perspective;

        const datasource = async () => {
            const request = fetch(URL);
            const worker = perspective.worker();
            const response = await request;
            const buffer = await response.arrayBuffer();
            return worker.table(buffer);
        };

        window.addEventListener("DOMContentLoaded", async function () {
            const table = await datasource();
            const view = table.view({
                row_pivots: ["Region", "State", "City"],
                column_pivots: ["Category", "Sub-Category"],
                columns: ["Sales", "Profit"],
            });

            const model = await create_view_cache(table, view);
        
            const regular = document.getElementsByTagName("regular-table")[0];
            regular.setDataListener(dataListener.bind(model));
        
            regular.addStyleListener(typeStyleListener.bind(model, regular));
            regular.addStyleListener(treeStyleListener.bind(model, regular));
            regular.addStyleListener(groupHeaderStyleListener.bind(model, regular));
            regular.addStyleListener(columnHeaderStyleListener.bind(model, regular));
        
            regular.addEventListener("mousedown", mousedownListener.bind(model, regular));

            await regular.draw();
        });
    </script>

</body>

</html>