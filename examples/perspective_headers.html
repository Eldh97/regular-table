<!--
   
   Copyright (c) 2020, the Regular Table Authors.
   
   This file is part of the Regular Table library, distributed under the terms of
   the Apache License 2.0.  The full license can be found in the LICENSE file.

-->

<!--

    An example of a multi-dimensional pivot table using [`regular-table`](https://github.com/jpmorganchase/regular-table)
    and [`perspective`](https://perspective.finos.org/). 
    
-->

<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <script src="../node_modules/@finos/perspective/dist/umd/perspective.js"></script>
    <script src="../dist/umd/regular-table.js"></script>
    <link rel='stylesheet' href="../dist/css/material.css">
    <style>
        /* Type Styles */
        .psp-align-right {
            text-align: right;
        }
        .psp-align-left {
            text-align: left;
        }
        .psp-positive {
            color: #1078d1;
        }
        .psp-negative {
            color: #de3838;
        }
        /* Tree Styles */
        .psp-tree-header {
           background-image: linear-gradient(to right, transparent 9px, #eee 10px, transparent 11px);
        }
        .psp-tree-label:before {
            content: "remove";
            color: #ccc;
            font-family: "Material Icons";
            margin-top: 4px;
            margin-right: 12px;
        }
        .psp-tree-label:hover:before {
            text-shadow: 0px 0px 5px #1078d1;
        }
        .psp-tree-edge {
            border-right: 1px solid #ddd;
        }
        .psp-tree-edge:not(.psp-tree-leaf) {
            pointer-events: none;
        }
        .psp-tree-indent {
            min-width: 20px;
            max-width: 20px;
        }
        .psp-tree-leaf {
            padding-left: 24px;
        }
        /* Header Styles */
        .psp-header-border {
            border-right: 1px solid #ddd;
        }
    </style>
</head>

<body>

    <regular-table></regular-table>

    <script>
        const FORMATTERS = {
            datetime: Intl.DateTimeFormat("en-us"),
            date: Intl.DateTimeFormat("en-us"),
            integer: Intl.NumberFormat("en-us"),
            float: new Intl.NumberFormat("en-us", {
                style: "decimal",
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
            }),
        };

        function* _tree_header(paths = []) {
            for (let path of paths) {
                path = ["TOTAL", ...path];
                yield path
                    .slice(0, path.length - 1)
                    .fill("")
                    .concat(path[path.length - 1]);
            }
        }

        class PerspectiveDataModel {
            _format(parts, val) {
                if (val === null) {
                    return "-";
                }
                const type = this._schema[parts[parts.length - 1]] || "string";
                return FORMATTERS[type]?.format(val) || val;
            }

            async _set_view(table, view) {
                this.view = view;
                this.table_schema = await table.schema();
                this._config = await view.get_config();
                this._num_rows = await view.num_rows();
                this._schema = await view.schema();
                this._column_paths = await view.column_paths();
                this._column_paths = this._column_paths.filter((path) => {
                    return path !== "__ROW_PATH__" && path !== "__ID__";
                });
            }

            async dataListener(x0, y0, x1, y1) {
                let columns = {};
                if (x1 - x0 > 0 && y1 - y0 > 0) {
                    columns = await this.view.to_columns({
                        start_row: y0,
                        start_col: x0,
                        end_row: y1,
                        end_col: x1,
                        id: this._config.row_pivots.length > 0,
                    });
                }

                const data = [];
                const column_headers = [];
                for (const path of this._column_paths.slice(x0, x1)) {
                    const path_parts = path.split("|");
                    data.push(columns[path].map((x) => this._format(path_parts, x)));
                    column_headers.push(path_parts);
                }

                return {
                    num_rows: this._num_rows,
                    num_columns: this._column_paths.length,
                    row_headers: Array.from(_tree_header(columns.__ROW_PATH__)),
                    column_headers,
                    data,
                };
            }

            typeStyleListener({detail: regularTable}) {
                for (const td of regularTable.querySelectorAll("td, thead tr:last-child th")) {
                    const metadata = regularTable.getMeta(td);
                    if (metadata.x >= 0) {
                        const column_path = this._column_paths[metadata.x];
                        const column_path_parts = column_path.split("|");
                        const type = this._schema[column_path_parts[column_path_parts.length - 1]];
                        const is_numeric = type === "integer" || type === "float";
                        const float_val = is_numeric && parseFloat(metadata.value);
                        td.classList.toggle("psp-align-right", is_numeric);
                        td.classList.toggle("psp-align-left", !is_numeric);
                        td.classList.toggle("psp-positive", float_val > 0);
                        td.classList.toggle("psp-negative", float_val < 0);
                    }
                }
            }

            treeStyleListener({detail: regularTable}) {
                for (const td of regularTable.querySelectorAll("tbody th")) {
                    const metadata = regularTable.getMeta(td);
                    const is_empty = !!metadata.value && metadata.value.trim().length > 0;
                    const is_leaf = metadata.row_header_x >= this._config.row_pivots.length;
                    td.classList.toggle("psp-tree-header", metadata.value === "");
                    td.classList.toggle("psp-tree-label", is_empty && !is_leaf);
                    td.classList.toggle("psp-tree-leaf", is_empty && is_leaf);
                    td.classList.toggle("psp-tree-edge", metadata.row_header_x === this._config.row_pivots.length);
                    td.classList.toggle("psp-tree-indent", metadata.row_header_x < this._config.row_pivots.length);
                }
            }

            groupHeaderStyleListener({detail: regularTable}) {
                for (const td of regularTable.querySelectorAll("thead tr:not(:last-child) th")) {
                    const metadata = regularTable.getMeta(td);
                    let needs_border = metadata.row_header_x === this._config.row_pivots.length || metadata.x >= 0;
                    td.classList.toggle("psp-header-border", needs_border);
                }
            }

            columnHeaderStyleListener({detail: regularTable}) {
                for (const td of regularTable.querySelectorAll("thead tr:last-child th")) {
                    const metadata = regularTable.getMeta(td);
                    let needs_border = metadata.row_header_x === this._config.row_pivots.length;
                    needs_border = needs_border || (metadata.x + 1) % this._config.columns.length === 0;
                    td.classList.toggle("psp-header-border", needs_border);
                }
            }
        }

        window.PerspectiveDataModel = PerspectiveDataModel;
    </script>
    
    <script>
        /**********************************************************************
         *
         * Example
         *
         */

        const URL = "../node_modules/superstore-arrow/superstore.arrow";
        const perspective = window.perspective;

        const datasource = async () => {
            const request = fetch(URL);
            const worker = perspective.worker();
            const response = await request;
            const buffer = await response.arrayBuffer();
            return worker.table(buffer);
        };

        window.addEventListener("DOMContentLoaded", async function () {
            const table = await datasource();
            const view = table.view({
                row_pivots: ["Region", "State", "City"],
                column_pivots: ["Category", "Sub-Category"],
                columns: ["Sales", "Profit"],
            });

            const model = new window.PerspectiveDataModel();
            await model._set_view(table, view);

            const regular = document.getElementsByTagName("regular-table")[0];
            regular.addStyleListener(model.typeStyleListener.bind(model));
            regular.addStyleListener(model.treeStyleListener.bind(model));
            regular.addStyleListener(model.groupHeaderStyleListener.bind(model));
            regular.addStyleListener(model.columnHeaderStyleListener.bind(model));
            regular.setDataListener(model.dataListener.bind(model));
            await regular.draw();
        });
    </script>

</body>

</html>